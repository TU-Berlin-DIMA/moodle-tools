"""This module implements SQL DQL questions in Moodle CodeRunner."""

import atexit
import re
from base64 import b64encode
from pathlib import Path

import duckdb
import sqlparse  # type: ignore

from moodle_tools.questions.coderunner import CoderunnerQuestion, Testcase
from moodle_tools.utils import ParsingError, preprocess_text


class CoderunnerSQLQuestion(CoderunnerQuestion):
    """Template for a SQL question in Moodle CodeRunner."""

    ACE_LANG = "sql"

    def __init__(
        self,
        question: str,
        title: str,
        answer: str,
        database_path: str,
        category: str | None = None,
        grade: float = 1.0,
        general_feedback: str = "",
        result: str | None = None,
        answer_preload: str = "",
        testcases: list[Testcase] | None = None,
        all_or_nothing: bool = True,
        check_results: bool = False,
        database_connection: bool = True,
        **flags: bool,
    ) -> None:
        """Create a new SQL question.

        Args:
            question: The question text displayed to students.
            title: Title of the question.
            answer: The piece of code that, when executed, leads to the correct result.
            database_path: Path to the DuckDB database (e.g., "./eshop.db").
            category: The category of the question.
            grade: The total number of points of the question.
            general_feedback: Feedback that is displayed once the quiz has closed.
            result: The expected result of the correct answer.
            answer_preload: Text that is preloaded into the answer box.
            testcases: List of testcases for checking the student answer. One test without changes
                to the database is generated by default for SQL DQL questions.
            all_or_nothing: If True, the student must pass all test cases to receive any
                points. If False, the student gets partial credit for each test case passed.
            check_results: If testcase_results are provided, run the reference solution and check
                if the results match.
            database_connection: If True, connect to the provided database to fetch the expected
                result. If False, use the provided result.
            flags: Additional flags that can be used to control the behavior of the
                question.
        """
        self.database_path = Path(database_path)
        if answer[-1] != ";":
            raise ParsingError(
                f"SQL queries must end with a ';' symbol. But the last symbol was: {answer[-1]}"
            )
        if database_connection:
            if not self.database_path.exists():
                raise FileNotFoundError(
                    f"Provided database path does not exist: {self.database_path}"
                )
            self.con = duckdb.connect(str(self.database_path))
            atexit.register(self.con.close)
        else:
            if result is None or (
                testcases and any("result" not in testcase for testcase in testcases)
            ):
                raise ParsingError(
                    "You must provide a result if you set database_connection to false. "
                    "Otherwise we cannot automatically fetch the result from the database."
                )

        super().__init__(
            question,
            title,
            answer,
            category,
            grade,
            general_feedback,
            result,
            answer_preload,
            testcases,
            all_or_nothing,
            check_results,
            **flags,
        )
        self.answer = sqlparse.format(self.answer, reindent=True, keyword_case="upper")

        for testcase in self.testcases:
            testcase["code"] = sqlparse.format(
                testcase["code"], reindent=True, keyword_case="upper"
            )

    @property
    def files(self) -> list[dict[str, str]]:
        with open(self.database_path, "rb") as file:
            files = {
                "name": self.database_path.name,
                "encoding": b64encode(file.read()).decode("utf-8"),
            }
        return [files]


class CoderunnerDDLQuestion(CoderunnerSQLQuestion):
    """Template for a SQL DDL/DML question in Moodle CodeRunner."""

    CODERUNNER_TYPE = "PROTOTYPE_duckdb_ddl"
    RESULT_COLUMNS = """[["Testfall", "extra"], ["Bewertung", "awarded"]]"""
    TEST_TEMPLATE = "testlogic_ddl.py.j2"

    def __init__(
        self,
        question: str,
        title: str,
        answer: str,
        database_path: str,
        category: str | None = None,
        grade: float = 1,
        general_feedback: str = "",
        result: str | None = None,
        answer_preload: str = "",
        testcases: list[Testcase] | None = None,
        all_or_nothing: bool = False,
        check_results: bool = False,
        database_connection: bool = True,
        **flags: bool,
    ) -> None:
        super().__init__(
            question,
            title,
            answer,
            database_path,
            category,
            grade,
            general_feedback,
            result,
            answer_preload,
            testcases,
            all_or_nothing,
            check_results,
            database_connection,
            **flags,
        )

        if check_results:
            self.check_results()

    def fetch_expected_result(self, test_code: str) -> str:
        self.con.sql("BEGIN TRANSACTION")
        self.con.sql(self.answer)

        # A DDL/DML test might include multiple statements, so we need to split them
        result = ""
        statements = [code for code in test_code.split(";") if code.strip()]
        for statement in statements:
            result += f"{self.con.sql(statement)}\n"

        self.con.sql("ROLLBACK")
        return result


class CoderunnerDQLQuestion(CoderunnerSQLQuestion):
    """Template for a SQL DQL question in Moodle CodeRunner."""

    CODERUNNER_TYPE = "PROTOTYPE_duckdb_dql"
    RESULT_COLUMNS = ""
    TEST_TEMPLATE = "testlogic_dql.py.j2"

    def __init__(
        self,
        question: str,
        title: str,
        answer: str,
        database_path: str,
        category: str | None = None,
        grade: float = 1,
        general_feedback: str = "",
        result: str | None = None,
        answer_preload: str = "",
        testcases: list[Testcase] | None = None,
        all_or_nothing: bool = True,
        check_results: bool = False,
        database_connection: bool = True,
        **flags: bool,
    ) -> None:
        super().__init__(
            question,
            title,
            answer,
            database_path,
            category,
            grade,
            general_feedback,
            result,
            answer_preload,
            testcases,
            all_or_nothing,
            check_results,
            database_connection,
            **flags,
        )

        if database_connection:
            self.question += preprocess_text(self.extract_expected_output_schema(answer), **flags)

        # For DQL questions we add a default test with no changes
        default_test: Testcase = {
            "code": "",
            "result": self.fetch_expected_result("") if result is None else result,
            "grade": 1.0,
            "hiderestiffail": False,
            "description": "",
            "show": "SHOW",
        }
        self.testcases = [default_test] + self.testcases

        # We use standardized test names and hide all tests but the first for this type of question
        for i, testcase in enumerate(self.testcases):
            testcase["description"] = f"Testfall {i + 1}"
            if i > 0 and testcases and "hidden" not in testcases[i - 1]:
                testcase["show"] = "HIDE"

        if check_results:
            self.check_results()

    def fetch_expected_result(self, test_code: str) -> str:
        self.con.sql("BEGIN TRANSACTION")
        self.con.sql(test_code)
        result = str(self.con.sql(self.answer))
        self.con.sql("ROLLBACK")
        return result

    def extract_expected_output_schema(self, query: str) -> str:
        """Extract the output schema of a query from its operators and its result.

        Args:
            query: The SQL query to parse.

        Returns:
            str: The output schema of the query.
        """
        # Run the query, so that we can then get the schema output
        result = self.con.sql(query)
        result_schema = result.description

        # Grab the ORDER BY statement so that we can get sorting information
        match = re.search(".*ORDER BY (.*);?", query, flags=re.IGNORECASE)
        if not match:
            raise ParsingError(
                f"Could not retrieve the column names from the order by statement from the query "
                f"{query}!"
            )

        # Splitting the order on "," and on " " to get the column name and the order modifier
        order_by_statements = match.group(1).replace(";", "").split(",")
        column_orderings = {}
        for item in order_by_statements:
            item_split = item.strip().split(" ")
            column_orderings.update({item_split[0]: item_split[1]})

        # Creating the output schema string, appending it to the question_text, and return it
        asc_desc_map = {"ASC": "↑", "DESC": "↓"}
        output_elements: list[str] = []
        for column in result_schema:
            column_name = column[0]
            if column_name in column_orderings:
                output_elements.append(
                    f"{column_name} ({asc_desc_map[column_orderings[column_name]]})"
                )
            else:
                output_elements.append(column_name)

        return "\nErgebnisschema:\n\n" + ", ".join(output_elements)
